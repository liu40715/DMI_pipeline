import numpy as np
import logging
logger = logging.getLogger(__name__)


def execute(data: list, fs: float, **kwargs) -> np.ndarray:
    """
    積分函數：使用精確梯形法將加速度訊號積分轉換為速度訊號，並處理漂移
    
    Args:
        data (np.ndarray): 加速度信號，單位為g
        fs (float): 取樣頻率（Hz）

    Returns:
        - velocity_mms (np.ndarray): 轉換後的速度訊號，單位為mm/s
    
    Raises:
        ValueError: 當輸入參數不正確時
        Exception: 當處理過程發生錯誤時
    """
    try:
        buffer = data[0]              # data[0] 已經是 BytesIO 物件，不用包
        buffer.seek(0)                # 確保指標從開頭開始
        data = np.load(buffer,allow_pickle=True)         # 獲得array格式
        # 參數檢查
        if not isinstance(data, np.ndarray):
            raise ValueError("data 必須是 numpy 陣列")
        if len(data) == 0:
            raise ValueError("data 不能為空陣列")
        if not isinstance(fs, (int, float)):
            raise ValueError("fs 必須是數值類型")
        if fs <= 0:
            raise ValueError("取樣頻率 fs 必須大於 0")
        if len(data) < 2:
            raise ValueError("資料長度必須至少為 2 個樣本點才能進行積分")
        
        # 移除直流分量（去除偏移）
        data_mean = np.mean(data)
        acceleration_processed = data - data_mean
        # 將加速度從g轉換為m/s²
        acceleration_ms2 = acceleration_processed * 9.81
        # 計算時間間隔
        dt = 1.0 / fs
        # 使用精確的梯形法積分
        velocity_ms = np.zeros_like(acceleration_ms2)
        for i in range(1, len(acceleration_ms2)):
            velocity_ms[i] = velocity_ms[i-1] + (acceleration_ms2[i-1] + acceleration_ms2[i]) * 0.5 * dt
        # 移除線性漂移（去趨勢化）
        time_points = np.arange(len(velocity_ms))
        # 使用最小二乘法擬合線性趨勢
        coeffs = np.polyfit(time_points, velocity_ms, 1)
        linear_trend = np.polyval(coeffs, time_points)
        velocity_ms = velocity_ms - linear_trend
        # 轉換為mm/s
        velocity_mms = velocity_ms * 1000.0
        logger.info("加速度積分轉換速度")
        return velocity_mms
        
    except Exception as e:
        logger.error(f"integ 發生例外: {e}")
        raise
